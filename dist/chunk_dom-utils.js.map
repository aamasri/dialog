{"version":3,"file":"chunk_dom-utils.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,iCAAiC,KAAK;AACtC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;AAGD;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB,kCAAkC,KAAK;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;AAKD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;;;;;AAMA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA,WAAW,sCAAsC;AACjD,aAAa;AACb;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;;;;AAKA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,qBAAqB;AAChC,aAAa,QAAQ;AACrB;AACO;AACP;;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAA0C;AACrD,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA,kEAAkE,QAAQ;AAC1E;;AAEA,6BAA6B;AAC7B,EAAE;AACF;;;;;AAKA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACO;AACP;;AAEA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA","sources":["webpack://@aamasri/dialog/./node_modules/@aamasri/dom-utils/dom-utils.js"],"sourcesContent":["/**\n * @fileOverview A collection of DOM utils to add syntactic sugar and supplement jQuery.\n * @author Ananda Masri\n * @version 1.0.4\n */\n\n\n\n/**\n * Defer execution until after document ready.\n *\n * Usage:\n *     import { ready } from 'dom-utils';\n *     ready().then(function() { ... });\n */\nexport const ready = () => new Promise((resolve) => {\n\tif (document.readyState !== 'loading')\n\t\tresolve($cache());\n\telse\n\t\tdocument.addEventListener('DOMContentLoaded', () => {\n\t\t\tresolve($cache());\n\t\t});\n});\n\n\n/**\n * Defer execution until after window has fully loaded (including images).\n *\n * Usage:\n * \t   import { loaded } from 'dom-utils';\n *     loaded().then(function() { ... });\n */\nexport const loaded = () => new Promise((resolve) => {\n\tif (document.readyState === 'complete')\n\t\tresolve($cache());\n\telse\n\t\twindow.addEventListener('load', () => {\n\t\t\tresolve($cache());\n\t\t});\n});\n\n\n\n\n// jQuery selector cache\n/**\n * Caches the jQuery window, document, & body elements.\n *\n * @returns {Object}\n */\nconst selectorCache = {};\nexport function $cache() {\n\tif (selectorCache.hasOwnProperty('$body') && selectorCache.$body.length)\n\t\treturn selectorCache;\n\n\tselectorCache.$window = jQuery(window);\n\tselectorCache.$document = jQuery(document);\n\tselectorCache.$body = jQuery('body');\n\n\treturn selectorCache;\n}\n\n\n\n/**\n * Whether the current window is actually a child window (contained in an iframe).\n *\n * @returns {boolean}\n */\nexport function isInIframe() {\n\treturn window.location !== window.parent.location;\n}\n\n\n/**\n * Whether this device has a touch screen.\n *\n * @returns {boolean}\n */\nlet cachedIsTouchDevice;\nexport function isTouchDevice() {\n\tif (typeof cachedIsTouchDevice === 'boolean')\n\t\treturn cachedIsTouchDevice;\n\n\tif (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {\n\t\tcachedIsTouchDevice = true;\n\t\treturn cachedIsTouchDevice;\n\t}\n\n\t// include the 'heartz' as a way to have a non matching MQ to help terminate the join\n\t// https://git.io/vznFH\n\tconst mq = function (query) {\n\t\tcachedIsTouchDevice = window.matchMedia(query).matches;\n\t\treturn cachedIsTouchDevice;\n\t};\n\n\tconst prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n\tconst query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n\tcachedIsTouchDevice = !!mq(query);\n\treturn cachedIsTouchDevice;\n}\n\n\n\n\n\n/**\n * Whether this device is a recognized mobile device.\n *\n * @returns {boolean}\n */\nexport function isMobile() {\n\treturn /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());\n}\n\n\n\n\n\n/**\n * Whether the specified element is visible (ie. css display/visibility/opacity and viewport scroll position).\n *\n * @param {Element | Node | ParentNode | jQuery} el\n * @returns {boolean}\n */\nexport function isVisible(el) {\n\tif (el instanceof jQuery)\n\t\tel = el[0];\n\n\t//is object hidden\n\tif (getAppliedStyle(el, 'display') === 'none' || getAppliedStyle(el, 'visibility') === 'hidden' || parseFloat(getAppliedStyle(el, 'opacity')) < 0.1)\n\t\treturn false;\n\n\tconst rect = el.getBoundingClientRect();\n\treturn (\n\t\trect.top >= 0 &&\n\t\trect.left >= 0 &&\n\t\trect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n\t\trect.right <= (window.innerWidth || document.documentElement.clientWidth)\n\t);\n}\n\n\n\n\n\n/** Returns the specified element's offset from the visible viewport.\n *\n * @param {Element | Node | ParentNode | jQuery} $element\n * @returns {Object | undefined}\n */\nexport function getViewportOffset($element) {\n\t$element = jQuery($element);\t// convert to all element types to jQuery\n\tif (!$element.length) {\n\t\tconsole.error('function getViewportOffset(element) expects a DOM element or jQuery object!');\n\t\treturn undefined;\n\t}\n\n\tconst offset = $element.offset();\n\tconst scroll = {};\n\tconst $win = $cache().$window;\n\n\tscroll.left = $win.scrollLeft();\n\tscroll.top = $win.scrollTop();\n\n\tconst left = offset.left - scroll.left;\n\tconst top = offset.top - scroll.top;\n\tconst right = $win.outerWidth() - left - $element.outerWidth();\n\tconst bottom = $win.height() - top - $element.outerHeight();\n\n\treturn { top, right, bottom, left };\n}\n\n\n\n\n/** Get the highest z-index in the document.\n *\n * @returns {number}\n */\nexport function onTopZIndex() {\n\tlet zTop = 0;\n\tconst elements = document.getElementsByTagName('*');\n\n\tfor (let i = 0; i < elements.length; i++) {\n\t\tlet zIndex = getZIndex(elements[i]);\n\n\t\tif (zIndex && zIndex > zTop)\n\t\t\tzTop = zIndex;\n\t}\n\n\treturn zTop;\n}\n\n\n\n\n\n/**\n * Get the z-index of the the specified element.\n * The recursive option will traverse the parent tree (z-index includes descendents)\n *\n * @param {Element | Node | ParentNode} element\n * @param {boolean | undefined} [recursive=undefined] - whether to traverse parents in search of z-index\n * @returns {number} - the z-index\n */\nexport function getZIndex(element, recursive) {\n\tconst zIndex = parseInt(getAppliedStyle(element, 'z-Index')) || 0;\n\n\treturn (recursive && zIndex === 0) ? getZIndex(element.parentNode, true) : zIndex;\n}\n\n\n\n\n\n/**\n * Get the computed style of the the specified element and style.\n *\n * @param {Element | Node | ParentNode} element\n * @param {string} style - eg. 'z-index' or 'margin'\n * @returns {string} - the style value\n */\nexport function getAppliedStyle(element, style) {\n\treturn window.getComputedStyle(element).getPropertyValue(style);\n}\n\n\n\n\n/**\n * Check for webp feature support. Some browsers initially introduced partial support i.e. for lossy images\n * (i.e. compression), then added lossless & alpha support, finally adding support for animation.\n *\n * Usage: webpSupport('animated').then(() => console.log(`webp supported`)).catch(errMsg => console.log(errMsg) )\n *\n * @param {('lossy'|'lossless'|'alpha'|'animation')} feature\n * @return {Promise}\n */\nexport function webpSupport(feature='alpha') {\n\treturn new Promise((resolve, reject) => {\n\t\tconst testImages = {\n\t\t\tlossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\n\t\t\tlossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\n\t\t\talpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\n\t\t\tanimation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\n\t\t};\n\t\tconst img = new Image();\n\n\t\timg.onload = () => {\n\t\t\tif ((img.width > 0) && (img.height > 0))\n\t\t\t\tresolve(`This browser supports webp images with ${feature}.`);\n\t\t\telse\n\t\t\t\treject(`This browser does NOT fully support webp images with ${feature}.`);\n\t\t};\n\t\timg.onerror = () => {\n\t\t\treject(`This browser does NOT fully support webp images with ${feature}`);\n\t\t};\n\n\t\timg.src = \"data:image/webp;base64,\" + testImages[feature];\n\t});\n}\n\n\n\n\n/**\n * Part of a system to determine the best image resolution for a given device.\n *\n * @returns {string} - lo|med|hi\n */\nexport function screenResolution() {\n\tconst pixelDensity = window.outerWidth * window.outerHeight;\n\t// iPhone SE:  320 x 568\t 182k\tlo\n\t// iPhone 8:   375 x 667     250k   lo\n\t// iPhone 8+:  414 x 736     305k   lo\n\t// iPad\":      768 x 1024    786k   med\n\t// iPad Pro+:  1024 x 1365   1.4M   med\n\t// my desktop: 1024 x 1920   2M     hi\n\t// my 4k:      3200 x 1800   5.8M   hi\n\n\tif (pixelDensity > 1500000)\n\t\treturn 'hi';\n\n\telse if (pixelDensity > 500000)\n\t\treturn 'med';\n\n\treturn 'lo';\n}\n\n\n/**\n * A simple, fast (faster than md5 etc) hash code generator.\n *\n * @param {string} content  - string to hash\n * @returns {string}\t\t- the unique hash code\n */\nexport function hash(content) {\n\tlet hash = '';\n\n\tif (content.length === 0)\n\t\treturn hash;\n\n\tfor (let i = 0; i < content.length; i++) {\n\t\tlet char = content.charCodeAt(i);\n\t\thash = ((hash << 5) - hash) + char;\n\t\thash = hash & hash; // Convert to 32bit integer\n\t}\n\n\treturn hash;\n}"],"names":[],"sourceRoot":""}